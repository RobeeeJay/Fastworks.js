{
  "name": "fastworks",
  "version": "0.3.7",
  "author": {
    "name": "Robee Shepherd",
    "email": "rob@robertsworld.org.uk"
  },
  "description": "A Fast Middleware Framework",
  "contributors": [
    {
      "name": "Robee Shepherd",
      "email": "rob@robertsworld.org.uk"
    }
  ],
  "main": "./lib/index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/RobeeeJay/Fastworks.js.git"
  },
  "dependencies": {
    "formidable": "1.0.11",
    "cookie": "0.0.4",
    "lactate": "0.10.11",
    "less": "1.3.1",
    "uglify-js": "1.3.4"
  },
  "keywords": [
    "html",
    "framework",
    "connect"
  ],
  "license": "GPL",
  "engine": {
    "node": ">=0.8"
  },
  "readme": "Fastworks.js\n============\n\nA fast middleware Connect alternative for Node.js users who want more speed with their convenience\n\nhttps://github.com/RobeeeJay/Fastworks.js/\n\n\n\nLicense\n=======\n\nThis framework is released under the GNU General Public License v3:\n\nhttp://www.gnu.org/copyleft/gpl.html\n\n\n\nInstallation\n============\n\nnpm install fastworks\n\n(yeah, you knew that, right?)\n\n\n\nDocumentation\n=============\n\nThe most up to date docs are usually in the Wiki on github:\n\nhttps://github.com/RobeeeJay/Fastworks.js/wiki\n\n\n\nTo Do\n=====\n\nAdd a lot more documentation\n\nMore modules, improve existing modules\n\nAdd more routers\n\nSpeed optimisations\n\n\n\nAbout the Author\n================\n\nFastworks.js was written by Robee Shepherd, after some 13 years of developing web applications. Having been coding since the age of 10, starting with BASIC and then Z80 assembley language on the ZX-81 and ZX Spectrum, Robee has journeyed through the hell of 16-bit DOS and Windows development in C/C++ where pointers regularly wrapped around, through 32-bit Windows, the early days of ASP and finally to the modern joyous world of Node.JS.\n\nThat's quite a lot of programming experience, with so little to show for it.\n\n\n\nWhat's It Do?\n=============\n\nFastworks is a Node.js framework where the start point is the router, multiple stacks is the order of the day, and destinations are the end game.\n\nIt's design goal is to be as flexible as Connect, but as fast as possible. Feature set should never compromise speed.\n\n\n\nStacks and Routes\n=================\n\nRather than having a single stack which is full of things you don't need for many types of connections, Fastworks is designed around the idea of multiple stacks of middleware, letting you bind them to routes.\n\nLet's create a simple stack for serving static assets!\n\n\tvar fw = require(\"fastworks\");\n\t\n\tvar stackStatic = new fw.Stack();\n\t\n\tstackStatic.append(new fw.CompressorLess({ staticDir: __dirname + \"/static\" }))\n\t           .append(new fw.CompressorJS({ staticDir: __dirname + \"/static\" }))\n\t           .append(new fw.StaticFile({ staticDir: __dirname + \"/static\" }));\n\nSince the append() method returns this, you can chain using it like the above. But if you prefer, you can write it long hand.\n\nNow, a few things. Firstly, a stack is pretty useless on its own, and secondly, a stack is processed in the order you append modules to it. So in the example above, CompressorLess is called first, and StaticFile is called last.\n\nOften there are multiple modules which do very similar things, where one might be a tiny bit easier and less typing. But seriously, it's faster this way, gives you more control, and for very little more typing. If you want lazy slow crap, go play with .NET, you don't deserve to play with Node.js.\n\nCompressorLess and CompressorJS are modules which compress *.less and *.jscript files into *.css and *.js files respectively, using the Less and Uglify-JS node modules respectively. StaticFile serves things like images, style sheets and javascript files, using the pretty nifty Lactate node module. According to the author's benchmarks, it can handle more than twice the requests per second that Connect's Send module can.\n\nNow, let's create a more complicated stack!\n\n\tvar stackFull = new fw.Stack();\n\t\n\tstackFull.append(new fw.ResponseTime())\n\t         .append(new fw.Profiler())\n\t         .append(new fw.FavIcon({ iconPath: __dirname + \"/static/favicon.ico\" }))\n\t         .append(new fw.ErrorHandler({ showError: true, stackTrace: true }))\n\t         .append(new fw.Limiter({ max: \"10mb\" }))\n\t         .append(new fw.Cookies())\n\t         .append(new fw.SignedCookies({ signKey: \"its a secret\" }))\n\t         .append(new fw.SignedSession({ signKey: \"its a secret\" }))\n\t         .append(new fw.Query())\n\t         .append(new fw.BodySimple())\n\t         .append(new fw.BodyJSON())\n\t         .append(new fw.BodyComplex());\n\nThis is a lot more full on. This stack is geared towards full blown webpages, definitely not static content. But here is one of the beautiful things about Fastworks, the first port of call is not the stack at all, it is the router!\n\nSo let's make a simple router! But before we do that, we need some functions to act as destinations for our routes.\n\n\tfunction notfoundPage(request, response)\n\t{\n\t\tresponse.writeHead(404, { \"Content-Type\": \"text/plain\" });\n\t\tresponse.end(\"File not found!\");\n\t}\n\t\n\tfunction normalPage(request, response)\n\t{\n\t\tresponse.writeHead(200, { \"Content-Type\": \"text/plain\" });\n\t\tresponse.end(\"Woop! Stuff is happening!\");\n\t}\n\nYes, I know, painfully simple, but these are examples! Anyway, now for the route.\n\n\tvar router = new fw.SimpleRouter();\n\t\n\trouter.addRoute(\"/images\", stackStatic, notfoundPage);\n\trouter.addRoute(\"/styles\", stackStatic, notfoundPage);\n\trouter.addRoute(\"/scripts\", stackStatic, notfoundPage);\n\trouter.addRoute(\"/\", stackFull, normalPage);\n\t\n\trouter.listen(true, 8080);\n\nAs you can see, we create a router, you can only have one per http/https server, and then we add some routes to it.\n\nThese are simple routes which match from top to bottom, but they are quick, however if you prefer to use regular expressions instead, then there is a router for those called RegExRouter. And I hope to add another option later, and include ways to sort them.\n\nAnyway, here we add three routes for our static content, all of which sit in our web directory under /static and get sent through our very small static stack! This is more efficient than the alternative of one big stack which becomes inefficient for certain connections.\n\nThe destination for our static routes is a 404 function, because if our static files are not served by the StaticFile module then it must be a 404!\n\nWe then have one final generic route which goes through our full stack that includes a very good error handler that will catch any error at all which occurs relating to that connection and because we set it to, show a full stack trace and error where possible.\n\nIt also has a profiler, which spams some useful profiling information to the console (I wouldn't recommend using this on a production server, it would fill log files quickly if you are redirecting the console to one), limits uploads to 10 megabytes, serves a favourite icon (yes this is probably better off in the static stack), copies cookies into the request.cookie object, any query options to request.query, and form fields to request.body.\n\nIn addition to that it validates signed cookies, and maintains a session object (request.session) any changes to which are updated live across the session.\n\n\n\nSupported Modules\n=================\n\nAs a first release, I made a list of the sort of modules I deemed essential from working with Connect. And then I looked at how Connect did them, and decided if it was good I'd do it the same (or similar) way, but if it was bad then I'd do it differently.\n\nHere are those that made it into the first release:\n\n\nResponseTime\n============\n\nAdds a X-Response-time header to the client output which times how long it takes to generate the page.\n\n\nErrorHandler\n============\n\nA catch-all error handler that optionally shows the error and a stack trace to the client, and can either display a built in error page or call a provided function if you wish to do something yourself instead.\n\n\nStaticFile\n==========\n\nFast static file serving module, using Lactate, resulting in it supporting gzipping and memory caching. You can of course disable the memory caching and alter the expiry time.\n\n\nCompressorLess\n==============\n\nAutomatically compiles less files into css, using the Less compiler. You can specify how often it checks to see if the css file has changed, because let's face it, doing that is faster than checking every single time! You can also choose just to compile and not compress the css.\n\n\nCompressorJS\n============\n\nThis is like the other compressor, but for client side Javascript files! It also supports an option not to compress files and the check interval, and as an added bonus you can enable support for the same @import \"filename\"; syntax that less uses, to include files before you compress!\n\n\nCookies\n=======\n\nUsing the cookie module, this takes the cookies sent from the client, and whacks them into a request.cookies object for easy access.\n\n\nSignedCookies\n=============\n\nThis must be included after Cookies for it to work, but once you've done that, any cookie values which are signed get put into a request.signedcookies object. How is a cookie value signed? Well there is a duplicate value which is prefixed with \"sig.\" and contains an sha1 hash of the value.\n\n\nSession\n=======\n\nA simple cookie based session object! Just check the request.session object and use it however you want! Everything is handled automatically, and changes are live so multiple connections of the same session have access to the same object.\n\n\nSignedSession\n=============\n\nJust like Session, but uses signed cookies to validate the session, and obviously requires the SignedCookies module to work properly. Every new session is created with a guid much like with Session, but this time that guid is signed with an sha1 hash using the provided key.\n\n\nQuery\n=====\n\nSplits up the query string and places it into a request.query object for easy access. That simple! After all, request.query.page is much easier to use than parsing the whole URL yourself, isn't it?\n\n\nLimiter\n=======\n\nWant to limit the size of uploads? Now you can! If the client provides the size of the upload, it can terminate the connection immediately if too big, otherwise it can terminate it once the limit is reached.\n\n\nProfiler\n========\n\nThis spams stuff to the log, including the requested URL, response time, and memory usage before and after the request. Guaranteed to fill your console with spam!\n\n\nBodySimple\n==========\n\nA form submission parser that puts simple form fields submitted into a request.body object.\n\nBodyJSON\n========\n\nJust like BodySimple, but for submitted JSON data!\n\nBodyComplex\n===========\n\nJust like the other two, but uses formidable to handle much more complicated form submissions, like file uploads.\n\n\nFavIcon\n=======\n\nA very simple favicon.ico server, which after the first read caches it in memory indefinitely. So it's fast!\n\n\nConnect\n=======\n\nJust in case there is a favourite Connect module that you can't live without, there is even a Connect module which lets you use pretty much any module designed for that as part of Fastworks. Just until a faster Fastworks specific one becomes available anyway!\n\nIf for connect you used it like this:\n\n\tapp.use(connect.logger('dev'));\n\nThen in Fastworks you can use it like this:\n\n\tstack.append({ module: connect.logger('dev') });\n\n\nBonus Feature\n=============\n\nProviding you have Fuser as part of your Unix/Linux distribution, or can install it, you can take advantage of the graceful restarting feature built into Fastworks.\n\nPut simply, if you want your Node.js app to continue serving connections whilst you restart it, providing you set the graceful option, it will send a TERM signal to the other node process, and grab the port as soon as it is available, then begin serving connections to it.\n\nMeanwhile, the node application that receives the TERM signal will stop listening to the port, wait until it has finished serving any existing connections, and then close gracefully.\n",
  "_id": "fastworks@0.3.4",
  "dist": {
    "shasum": "9f78a916bda0ecd575d877b8d86fb421eb3a840e"
  },
  "_from": "fastworks@0.3.4"
}
